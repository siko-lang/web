<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Siko programming language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">2.</strong> Language reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">2.1.</strong> Modules</a></li><li class="chapter-item expanded "><a href="data_types.html"><strong aria-hidden="true">2.2.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="adt.html"><strong aria-hidden="true">2.2.1.</strong> Algebraic data types</a></li><li class="chapter-item expanded "><a href="record.html"><strong aria-hidden="true">2.2.2.</strong> Records</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">2.4.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">2.5.</strong> Type classes</a></li><li class="chapter-item expanded "><a href="effects.html"><strong aria-hidden="true">2.6.</strong> Effects</a></li></ol></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">3.</strong> Memory management</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Siko programming language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The idea of Siko was born out of frustration of current programming languages (as it is usually the case with any new programming language). I noticed that you can write most algorithms in most of the programming languages but you cannot simply reuse that algorithm in another programming language. You have to manually convert the algorithm from one language to another, considering all the little differences between the two languages. There is something fundamentally broken in the way we express ourselves in a programming language. The computer cannot really understand your code and it cannot just convert the fundamentals of the algorithm between languages. They are so different at the basic level that you cannot include a Haskell module in a C program or cannot simply use a Java lib in a python module without extraordinary hacks.
I believe the root cause of this issue is that programming languages have well defined runtime semantics and those are usually fully incompatible with some other programming language. However, the code we write does not necessarily have this property. Siko is an experiment in finding a way that can truly capture the essence of an algorithm where both the reader and the compiler can understand the code equally. Siko tries to be a runtime independent programming language, every concept/behaviour in the language is designed to be fully unabmiguous regardless of the actual runtime of target system.
Siko compiles everything down into primitives so general that any runtime can execute them equally. Siko does not have its own runtime and it could be transpiled into any other language or even compiled into runtime-less native code.
The current compiler only supports transpiling into Rust.</p>
<p>The syntax of Siko is heavily inspired by the syntax of Haskell. Siko being a value only language, the syntax of another value only language fits very well.</p>
<p>A taste of Siko:</p>
<pre><code class="language-Siko">module Main where

data City = { name :: String,
              population :: Int
            }

bigCities = List.filterMap cities (\c -&gt; if c.population &gt; 1000000 then Some c.name else None)

main = do
    cities &lt;- [City &quot;New York&quot; 18823000,
               City &quot;Los Angeles&quot; 12459000,
               City &quot;Los Alamos&quot; 20131]
    println &quot;Big cities {}&quot; % (bigCities cities)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-reference"><a class="header" href="#language-reference">Language reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>A Siko program is simply a collection of modules and modules are a collection of other definitions.
Every data type/function/typeclass/effect belongs to a single module. Modules are named and their names can contain the '.' character but they are not hierarchical. All modules simply exist at the same level.
The definiton of a module start wit the <code>module</code> keyword and ends at the end of the file or at the start of the next module.</p>
<pre><code class="language-Siko">
module My.First.Module where

foo = 0

module This.Is.A.New.Module.Not.Included.In.My.First.Module where

bar = 0

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>Siko currently supports algebraic data types and records. Every data type in the language is either an algebraic data type or a record, including base types such as String, Bool and Int.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic data types</a></h1>
<p>Algebraic data types are defined using the <code>data</code> keyword.</p>
<pre><code class="language-Siko">
data Month = January
           | February
           | March
           | TheOthers

data Expr = Lit Int
          | Sum Expr Expr
          | Mul Expr Expr

</code></pre>
<p>Types can be generic:</p>
<pre><code class="language-Siko">
data Option a = Some a | None

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>Records are data types with named fields and they are defined with the <code>data</code> keyword and <code>{</code> <code>}</code> characters.</p>
<pre><code class="language-Siko">
data School = { name :: String,
                location :: String }

data Student = { name :: String,
                 age :: Int
                 school :: School }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Although Siko is an imperative programming language, it is heavily functional in its style, thus functions play a crucial role in Siko programs.</p>
<p>Function definition examples</p>
<pre><code class="language-Siko">
id a :: a -&gt; a
id a = a

factorial :: Int -&gt; Int
factorial n = if n &lt; 2 then 1 else n * factorial (n - 1)

factorial2 0 = 1
factorial2 n = n * factorial2 (n - 1)

</code></pre>
<p>The body of a function is an expression that is evaluated when the function is called and the value of the expression is the return value of the function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>The body of a function is an expression that is evaluated when the function is called and the value of the expression is the return value of the function.</p>
<h3 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h3>
<h4 id="do"><a class="header" href="#do">do</a></h4>
<pre><code class="language-Siko">
foo = do
    msg &lt;- &quot;Hello world&quot;
    println msg

</code></pre>
<p>The <code>do</code> expression is a syntactic equivalent of a normal imperative block. It starts with the <code>do</code> keyword and contains one or more expressions which are evaluated in order, <code>do</code> blocks also provide scoping for name bindings. The return value of a <code>do</code> block is the value of the last expression in the block.</p>
<h4 id="bind"><a class="header" href="#bind">bind</a></h4>
<pre><code class="language-Siko">
foo = do
    (a, b) &lt;- (1, 'a')

</code></pre>
<p>The bind expression binds the value of the expression on the right hand side to the pattern on the left hand side and they are separated by the <code>&lt;-</code> symbol. Only irrefutable patterns are allowed in bind expressions. The return value of a bind expression is <code>()</code>.</p>
<h3 id="function-application"><a class="header" href="#function-application">function application</a></h3>
<p>The function application expression calls a function with the given arguments, evaluating to the return value of the function call.</p>
<pre><code class="language-Siko">
id a = a

foo = id 1

</code></pre>
<p>Functions are curried, partial function application has no special syntax.</p>
<pre><code class="language-Siko">
adder a b = a + b

foo = do
    f &lt;- adder 1
    res &lt;- f 2

</code></pre>
<h3 id="literals"><a class="header" href="#literals">literals</a></h3>
<pre><code class="language-Siko">
literals = do
    i1 &lt;- -1
    i2 &lt;- 123
    pi &lt;- 3.14
    msg &lt;- &quot;Hello world&quot;
    char &lt;- 'a'
    tuple &lt;- (i1, '4', (&quot;another&quot;,), ())

</code></pre>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p>The <code>if</code> expression can be used to create conditional expressions, the <code>else</code> block is always required. The <code>if</code> expression evaluates either the true branch or the false branch and returns the value of selected branch.</p>
<pre><code class="language-Siko">
isLarge n = if n &gt; 10 then True else False

</code></pre>
<h3 id="case"><a class="header" href="#case">case</a></h3>
<p>The <code>case</code> expression is used for pattern matching on values. The <code>case</code> expression evaluates the first branch that matches the value and returns the value of the expression in the selected branch.</p>
<pre><code class="language-Siko">
isLarge n = case n of
    1 -&gt; False
    n if n &lt;= 10 -&gt; False
    _ -&gt; True

</code></pre>
<h3 id="record-field-access"><a class="header" href="#record-field-access">record field access</a></h3>
<p>To access a field of a record, use a <code>.</code> followed by the name of the field. The value of the record field access expression is the value of the field.</p>
<pre><code class="language-Siko">
data Person = { name :: String, age :: Int }

getAge :: Person -&gt; Int
getAge p = p.age

</code></pre>
<h3 id="tuple-field-access"><a class="header" href="#tuple-field-access">tuple field access</a></h3>
<p>To access a field of a tuple, use a <code>.</code> followed by the index of the field. The value of the tuple field access expression is the value of the field.</p>
<pre><code class="language-Siko">
second a b :: (a, b) -&gt; b
second t = t.1

</code></pre>
<h3 id="lambda"><a class="header" href="#lambda">lambda</a></h3>
<p>The lambda expression is an unnamed function definition that evaluates to a function. The lambda expression starts with a <code>\</code> followed by the
lambda arguments then a <code>-&gt;</code> followed by an expression that is the body of the lambda function.</p>
<pre><code class="language-Siko">
test = do
    f &lt;- \x, y -&gt; x + y
    f 2 3

</code></pre>
<h3 id="return"><a class="header" href="#return">return</a></h3>
<p>The <code>return</code> expression stops the execution of the current function and returns the value of the expression given as the argument.</p>
<pre><code class="language-Siko">
test = return ()

</code></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<p>The <code>loop</code> expression resembles an imperative loop. It has a pattern, an initializer expression and a body.
The loop is started by evaluating the initializer expression, its value is then matched with the given pattern and then the body is executed once. After the execution, the value of the body is matched with the given pattern and the body is executed again, forever.</p>
<pre><code class="language-Siko">
loopTest =
    loop index &lt;- 1 do
        print &quot;Cycle count {}&quot; % index
        index + 1
</code></pre>
<h3 id="break"><a class="header" href="#break">break</a></h3>
<p>The <code>break</code> expression jumps out of the current <code>loop</code> and the return value of the loop will be the value of the expression given as the argument of break.</p>
<pre><code class="language-Siko">
loopTest = loop index &lt;- 1 do
        print &quot;Cycle count {}&quot; % index
        if index &gt; 10
            then break ()
            else index + 1
</code></pre>
<h3 id="continue"><a class="header" href="#continue">continue</a></h3>
<p>The <code>continue</code> expression jumps out of the current <code>loop</code> body and loop's current value will be the value of the expression given as the argument of continue.</p>
<pre><code class="language-Siko">
loopTest = loop index &lt;- 1 do
        print &quot;Cycle count {}&quot; % index
        if index &gt; 10
            then continue 0
            else index + 1
</code></pre>
<h3 id="try"><a class="header" href="#try">try</a></h3>
<p>The <code>try</code> expression evaluates its argument and 'unwraps' it, in case of failure the value is returned. It is currently sugar for a simple case.</p>
<pre><code>    ok_value &lt;- try fallibleOperation

    ok_value &lt;- case fallibleOperation of
        Ok v -&gt; v
        Err e -&gt; return e
</code></pre>
<h3 id="patterns"><a class="header" href="#patterns">Patterns</a></h3>
<p>#TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes"><a class="header" href="#type-classes">Type classes</a></h1>
<p>Type classes in Siko represent interfaces, it is a way to describe that a particular set of types support a set of operations.</p>
<pre><code class="language-Siko">class ToString a where
    toString a :: a -&gt; String
</code></pre>
<p>The type class above describes an interface where everything that implements it can be converted to a String. This is very similar to type classes
from Haskell or traits from Rust.</p>
<p>To describe that a given type implements a given type class an instance of that type class has to be defined for the given type.</p>
<pre><code class="language-Siko">data Person = { name :: String }

instance ToString Person where
    toString person = person.name
</code></pre>
<p>Siko currently supports single parameter type classes and non overlapping instances.</p>
<p>Type classes support associated types (similar to Rust's associated types), they are defined using the <code>&gt;</code> character.</p>
<pre><code class="language-Siko">class Iterator a &gt; b where
   next a b :: a -&gt; (a, Option b)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects"><a class="header" href="#effects">Effects</a></h1>
<p>Effects are used to describe that the code wants to use an operation with given semantics and type but the implementation of the operation is unknown and will be decided later by the caller. Effects meant to be a way to inject functionality into code with very little boilerplate.
The idea behind effects is that libraries should use effects to describe all their interactions with the external world and let the users decide how to implement those interactions. The effect interface provides a type safe communication between the library author and the library user.</p>
<p>Effects can appear in the function type but usually they are not present and are inferred by the compiler. The idea is that introducing, changing or removing an effect should not be an activity that affects all function signatures in the call chain, only the effect user and the effect handler functions are affected.</p>
<p>A simple example</p>
<pre><code class="language-Siko">
effect Log where
    log :: String -&gt; ()

someFunc :: () using (Log)
someFunc = do
    msg &lt;- &quot;Hello world&quot;
    log msg

logConsole msg = println msg

main = do
    with { log = logConsole } do
        someFunc
</code></pre>
<p>In the example above the someFunc function uses the effect called Log. In the example the effect appears in its signature but this effect declaration is fully optional, the list of used effects can be inferred by the compiler.</p>
<p>The <code>with</code> block introduces an effect handler, it specifies that the log effect call must be handled by the call logConsole for everything inside the with block (including the someFunc call).</p>
<p>Effect handlers can be static or dynamic and effects can introduce types as well.</p>
<h2 id="effect-syntax"><a class="header" href="#effect-syntax">Effect syntax</a></h2>
<h3 id="effect-definition"><a class="header" href="#effect-definition">Effect definition</a></h3>
<p>Effects are defined using the <code>effect</code> keyword, otherwise they are very similar to type class definitions. This is not a coincidence. Effects are very similar to type classes, they define an interface, however effects are not bound to types, but scopes.</p>
<p>An effect definition:</p>
<pre><code class="language-Siko">
effect (Show a) =&gt; Factory a where
    create a :: a

</code></pre>
<p>The effect above defines a factory that has a single call called <code>create</code> which can create an instance of some type a that implements the interface of the Show typeclass. The effects user does not know what the returned type of a will be, only that it can be converted into a String (using Show).</p>
<h3 id="declaring-used-effects-in-function-signatures"><a class="header" href="#declaring-used-effects-in-function-signatures">Declaring used effects in function signatures</a></h3>
<pre><code class="language-Siko">
someFunc a :: Int -&gt; String using (Factory a)
</code></pre>
<p>Effects in function signatures are declared using the <code>using</code> keyword. The type parameters of effects are part of the type parameter list of the function signature. Used effect declarations are optional part of a function signature.</p>
<h3 id="defining-handlers"><a class="header" href="#defining-handlers">Defining handlers</a></h3>
<pre><code class="language-Siko">
someFunc = do
    with { someOp = myOp } do
        otherCall
</code></pre>
<p>Effect handlers are defined using the <code>with</code> keyword, the <code>with</code> block contains a list of definitions. Each definition defines that a effect call is handled by the given handler.</p>
<h2 id="static-effects"><a class="header" href="#static-effects">Static Effects</a></h2>
<p>Static effects are effects with a statically dispatched handler, i.e. the compiler can decide, at compile time, which function will be called as the effect handler.</p>
<pre><code class="language-Siko">
import IO

effect FileOps where
    open :: String -&gt; File
    read :: File -&gt; String

someFunc :: String using (FileOps)
someFunc = do
    f &lt;- open &quot;my.txt&quot;
    read f

main = do
    with { open = IO.openFile, read = IO.readFile } do
        println someFunc
</code></pre>
<p>In the above example, the <code>open</code> is defined to be handled by <code>IO.openFile</code> which is a statically known function's name without any argument, so the effect handler does not have any associated environment. Thus, this call can be statically dispatched, i.e. the <code>open</code> call in <code>someFunc</code> can be simply replaced by <code>IO.openFile</code> in the generated code. This type of effect call has zero runtime overhead, it is essentially a type safe search and replace.</p>
<h2 id="dynamic-effects"><a class="header" href="#dynamic-effects">Dynamic Effects</a></h2>
<p>Dynamic effects are effects with a runtime defined environment attached to the handler. In these cases, the compiler can not statically dispatch the handler at compile time.</p>
<pre><code class="language-Siko">
import IO

data Config = Config String

effect ConfigProvider where
    get :: () -&gt; Config

someFunc :: String using (ConfigProvider)
someFunc = do
    Config c &lt;- get ()
    c

main = do
    config &lt;- Config &quot;myConfig&quot;
    with { get = \_ -&gt; config } do
        println someFunc
</code></pre>
<p>In the above example, the <code>get</code> is defined to be handled by a closure which is a runtime defined entity with an associated environment (contains the value of config). Thus, this call can only be dynamically dispatched. In this scenario, the compiler injects the closure as a hidden argument to all affected function, i.e. <code>someFunc</code> will have an extra parameter that contains the closure which will be called by the <code>get</code> call at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h1>
<p>Siko being a runtime agnostic programming language, its memory management solution must be as barebone as possible.
Other programming languages with heavy runtimes usually provide garbage collection solutions which have a global side effect. Every value in the system is affected by this decision, being a garbage collected language is a global property. The idea behind Siko's memory management is to get rid of this runtime dependent global property. The only global property values in Siko have is that they exist. Of course, they can have other properties, depending on their type, but none of the properties are true for every value in the program. Because Siko is not a low level system language, we do not have the need to be able to create pointers to every value in the program or to be able to meticulously define the storage type of every value. This gives freedom to the compiler to decide the details and freedom to the user to not care as much. On the other hand, nobody wants a slow language so the compiler must be able to generate code that is quite performant.</p>
<p>The exact memory management strategy used by the Siko compiler is that every value is moved at their last use and borrowed at every previous use.</p>
<pre><code class="language-Siko">data Person = { name :: String } deriving (Show)

main = do
    john &lt;- Person &quot;John Wick&quot;
    println john
    println john
    println john
</code></pre>
<p>In this particular example, the value &quot;John Wick&quot; is created when the constructor of Person is called and since that is the last use of the value,
the String is moved into the Person record. The john value is used 3 times, two of those will receive a borrowed john, the last one receives an owned version.</p>
<p>It is very much possible that a value is still being borrowed while their last use will move them. The Siko compiler tracks all borrows and promotes those affected borrows to owned values to avoid use after free bugs at runtime. This tracking is completely done at compile time for the whole program and does not require runtime support.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/custom-highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
