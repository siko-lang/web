<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Traits and instances - Siko Programming Language</title><meta name=description content="A blog about the Siko programming language"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs.min.css><link rel=stylesheet href="/style.css?v=foobar"></head><body><header class=blog-header><div class=logo-container><img src=/logo.png alt="Siko programming language" id=logo></div><h1 class=blog-title>Siko Programming Language</h1></header><main><div class=blog-container><div class=blog-entry><div class=blog-date>2025 August 30</div><h1 id=traits-and-instances>Traits and instances</h1><p>This post will explain how the trait system and instance resolution works in Siko.
Siko uses traits for describing interfaces, they can be used to constrain generic types in generic functions.
Here is a sample trait:</p><pre tabindex=0><code class=language-siko data-lang=siko>trait Foo[T] {
  fn foo(self) -&gt; ()
}
</code></pre><p>This trait expresses that whatever type has an instance for this trait, that type will have a foo method that returns an empty
tuple. To be able to use the trait in practice you need to add instances for types.</p><pre tabindex=0><code class=language-siko data-lang=siko>struct Bar {

}

instance Foo[Bar] {
  fn foo(self) -&gt; () {

  }
}
</code></pre><p>This instance expresses that the struct Bar implements the Foo interface and if you call its foo() method then the instance&rsquo;s implementation will be used. Let&rsquo;s use it.</p><pre tabindex=0><code class=language-siko data-lang=siko>
fn someFunc[T: Foo[T]](value: T) {
  value.foo();
}

fn main() {
  let b = Bar();
  b.foo(); // this calls the instance&#39;s foo() function
  someFunc(b); // the monomorphized version of someFunc will call the same foo() function
}
</code></pre><p>So far this is kind of what you would expect in a language with generics, it even uses standard naming for these patterns. No surprise there. The cool part is how Siko mixes global instance resolution with Scala style scope based resolution.</p><h3 id=canonical-instances>Canonical instances</h3><p>If you do not add a name to your instance then it will be a so called canonical instance. It behaves as you would expect if you are familiar with Rust&rsquo;s type system (or any other similar system) and it is available globally. For each type and trait pair there can be only a single canonical instance. This ensures that canonical instances are unambiguous. In Rust lingo, this property is called coherence.</p><h3 id=resolution-of-scoped-instances>Resolution of scoped instances</h3><p>However, we are not stopping here. You can add names to instances and then they become something that you can export from your module and import from other modules.</p><pre tabindex=0><code class=language-siko data-lang=siko>module A {

// this instance is named MyFooInstance and it is exported (due to the pub keyword)
pub instance MyFooInstance Foo[Bar] {
  fn foo(self) -&gt; () {

  }
}

}

module Main {

import A // this imports all public items, including MyFooInstance

fn someFunc[T: Foo[T]](value: T) {
  value.foo();
}

fn main() {
  let b = Bar();
  b.foo();
  someFunc(b);
}

}
</code></pre><p>The exact order of resolution is the following:</p><ul><li>module local instances have the highest priority</li><li>imported instances have a slightly lower priority</li><li>if all else fails then global, canonical instances are searched</li></ul><p>In case there are multiple matching candidate instances (in any of the priority levels) then the resolution fails with instance ambiguity.
This system ensures that you have fine grained control over which instance(s) are used in which context. You do not have to worry about other modules creating unwanted instances.
You can easily create local specialized instances which do not affect the other parts of your program. We do not need complex algorithms to sort instances and try to figure out which one is &lsquo;more specialized&rsquo; and you can write as many different instances as you want.</p><p>Additionally, you can still keep the same level of ease-of-use that you&rsquo;d expect and there is no extra boilerplate or manually passing around instances.</p><h3 id=the-drop-trait>The Drop trait</h3><p>There is a corner case in the system, the handling of instances for Drop. The Drop trait defines a type&rsquo;s destructor. The Drop trait behaves differently compared to other traits because the compiler can conjure up Drop implementations for types which do not have Drop instances. These functions are not bound to a scope
so using scope bound instances for Drop would not make any sense.
The solution Siko uses is that Drop instances must be canonical instances which I think even make sense conceptually. You really do not want multiple destructors for a type.</p></div><div style="margin-top:2em;padding-top:1em;border-top:1px solid #ddd"><a href=/%20/>&larr; Back to blog</a></div></div></main><table style=margin-top:1em><tr><td><a href=https://github.com/siko-lang/siko target=_blank rel=noopener title=GitHub><img src=/github.svg alt=GitHub height=32 width=32 style=vertical-align:middle;filter:grayscale(1)></a></td><td><a href=https://discord.gg/Gfd8YDrYVC target=_blank rel=noopener title=Discord><img src=/discord.svg alt=Discord height=32 width=32 style=vertical-align:middle></a></td></tr></table><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src="/siko-syntax.js?v=2025-08-30"></script></body></html>