<!doctype html><html lang=en-us dir=ltr><head><meta name=generator content="Hugo 0.149.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Siko Programming Language</title><meta name=description content="A blog about the Siko programming language"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs.min.css><link rel=stylesheet href="/style.css?v=foobar"></head><body><header class=blog-header><div class=logo-container><img src=/logo.png alt="Siko programming language" id=logo></div><h1 class=blog-title>Siko Programming Language</h1></header><main><div class=blog-container><div class=blog-entry><div class=blog-date>2025 August 30</div><h2 id=traits-and-instances><a href=https://siko-lang.github.io/posts/traits-and-instances/>Traits and instances</a></h2><p>This post will explain how the trait system and instance resolution works in Siko.
Siko uses traits for describing interfaces, they can be used to constrain generic types in generic functions.
Here is a sample trait:</p><pre tabindex=0><code class=language-siko data-lang=siko>trait Foo[T] {
  fn foo(self) -&gt; ()
}
</code></pre><p>This trait expresses that whatever type has an instance for this trait, that type will have a foo method that returns an empty
tuple. To be able to use the trait in practice you need to add instances for types.</p><pre tabindex=0><code class=language-siko data-lang=siko>struct Bar {

}

instance Foo[Bar] {
  fn foo(self) -&gt; () {

  }
}
</code></pre><p>This instance expresses that the struct Bar implements the Foo interface and if you call its foo() method then the instance&rsquo;s implementation will be used. Let&rsquo;s use it.</p><pre tabindex=0><code class=language-siko data-lang=siko>
fn someFunc[T: Foo[T]](value: T) {
  value.foo();
}

fn main() {
  let b = Bar();
  b.foo(); // this calls the instance&#39;s foo() function
  someFunc(b); // the monomorphized version of someFunc will call the same foo() function
}
</code></pre><p>So far this is kind of what you would expect in a language with generics, it even uses standard naming for these patterns. No surprise there. The cool part is how Siko mixes global instance resolution with Scala style scope based resolution.</p><h3 id=canonical-instances>Canonical instances</h3><p>If you do not add a name to your instance then it will be a so called canonical instance. It behaves as you would expect if you are familiar with Rust&rsquo;s type system (or any other similar system) and it is available globally. For each type and trait pair there can be only a single canonical instance. This ensures that canonical instances are unambiguous. In Rust lingo, this property is called coherence.</p><h3 id=resolution-of-scoped-instances>Resolution of scoped instances</h3><p>However, we are not stopping here. You can add names to instances and then they become something that you can export from your module and import from other modules.</p><pre tabindex=0><code class=language-siko data-lang=siko>module A {

// this instance is named MyFooInstance and it is exported (due to the pub keyword)
pub instance MyFooInstance Foo[Bar] {
  fn foo(self) -&gt; () {

  }
}

}

module Main {

import A // this imports all public items, including MyFooInstance

fn someFunc[T: Foo[T]](value: T) {
  value.foo();
}

fn main() {
  let b = Bar();
  b.foo();
  someFunc(b);
}

}
</code></pre><p>The exact order of resolution is the following:</p><ul><li>module local instances have the highest priority</li><li>imported instances have a slightly lower priority</li><li>if all else fails then global, canonical instances are searched</li></ul><p>In case there are multiple matching candidate instances (in any of the priority levels) then the resolution fails with instance ambiguity.
This system ensures that you have fine grained control over which instance(s) are used in which context. You do not have to worry about other modules creating unwanted instances.
You can easily create local specialized instances which do not affect the other parts of your program. We do not need complex algorithms to sort instances and try to figure out which one is &lsquo;more specialized&rsquo; and you can write as many different instances as you want.</p><p>Additionally, you can still keep the same level of ease-of-use that you&rsquo;d expect and there is no extra boilerplate or manually passing around instances.</p><h3 id=the-drop-trait>The Drop trait</h3><p>There is a corner case in the system, the handling of instances for Drop. The Drop trait defines a type&rsquo;s destructor. The Drop trait behaves differently compared to other traits because the compiler can conjure up Drop implementations for types which do not have Drop instances. These functions are not bound to a scope
so using scope bound instances for Drop would not make any sense.
The solution Siko uses is that Drop instances must be canonical instances which I think even make sense conceptually. You really do not want multiple destructors for a type.</p></div><div class=blog-entry><div class=blog-date>2025 August 20</div><h2 id=implicits-and-effect-handlers><a href=https://siko-lang.github.io/posts/implicits-effect-handlers/>Implicits and effect handlers</a></h2><p>Siko now supports <strong>implicits</strong> and <strong>effect handlers</strong>.
Because it may not be obvious what these features do and more importantly how they are implemented,
we will look into them using a simple teletype example. Without much further ado, let&rsquo;s dive into the code.
Here is the full example and we will explore it in detail afterwards.</p><pre tabindex=0><code class=language-siko data-lang=siko>module TeleType {

pub effect TeleType {
  fn readLine() -&gt; String
  fn println(input: &amp;String)
}

pub fn run() {
  while True {
    let input = readLine();
    if input == &#34;exit&#34; {
      break;
    }
    println(&#34;You said: &#34; + input);
  }
}

}

module Main {

import TeleType as T

implicit mut state: Int

fn mockReadLine() -&gt; String {
  if state &lt; 3 {
    state += 1;
    &#34;mocked: ${state}&#34;
  } else {
    &#34;exit&#34;.toString()
  }
}

fn mockPrintln(input: &amp;String) {
  let expectedString = &#34;You said: mocked: ${state}&#34;;
  assert(expectedString == input);
}

fn testTeleType() {
  let mut state = 0;
  with T.println = mockPrintln,
     T.readLine = mockReadLine,
     state = state {
    T.run();
  }
}

fn realTeleType() {
  println(&#34;Starting teletype&#34;);
  with T.println = println,
       T.readLine = readLine {
    T.run();
  }
}

fn main() {
  testTeleType();
  realTeleType();
}

}
</code></pre><p>The example program defines a single TeleType effect that allows for reading and writing to the console in a
controlled manner. The effect definition looks similar to a trait definition because it acts as an interface
but in contrast to instances (the trait implementations), effects are not handled globally, their actual
implementation is context dependent. The execution context of a code block determines how the effect is handled.
In other words, the effect acts as a hole in the program, allowing the caller to control what happens when
an effect is called.
Because Siko is a low level programming language, it does not have a language
specific runtime, it does not do stack juggling in a way that you would expect if you heard about algebraic
effects previously.</p><p>In Siko, effects are statically resolved at compile time and every function that uses an effect is monomorphized
to a specific implementation of the effect. In the actual compiled code, there are no runtime
checks or dynamic dispatch involved when dealing with effects. In the case of the teletype example, the teletype
loop is compiled twice, once for testing and once for real execution. When the monomorphizer encounters a
<em>with</em> block it updates the effect handlers in the current context, so that whenever an effect call is encountered, the
selected implementation will simply replace the effect call. This is as static as it gets, the function call is
literally just replaced. Obviously, everything is type checked and the monomorphizer will complain if
the effect is not handled properly, i.e. the current context does not provide an implementation for an
encountered effect call.</p><p>So far so good, but you may be wondering: the usability of this is questionable because it is not
possible to attach state to the effect calls. That&rsquo;s where implicits come into play! Similarly to effects, implicits are also
context dependent, but they are not functions, rather they are variables that can be used in the current context. They don&rsquo;t
provide functionality, they provide state. In the example, we define an implicit variable named <em>state</em> that keeps
track of the current state of the test executor. Implicits are bound to local variables using the with block,
similarly to effects. Every code in that execution context (arbitrarily deep in the callchain) that wants to use the implicit
variable can do so and will use the bound local variable behind the scenes. As you can see, the actual teletype implementation is not aware of
the test code injecting state into the loop. Implicits can be immutable and mutable. Implicits are compiled away
into an implicitly passed context parameter. The context variable contains a list of implicits in the current execution
context and each access to the implicit is replaced by accessing the correct member of the context variable.</p><p>I find both implicits and effect handlers a clean abstraction but there are still open design questions.
For example, Siko currently does not have closures but I want to introduce them and their interaction with
effects and implicits is not yet clear.</p></div><div class=blog-entry><div class=blog-date>2025 August 19</div><h2 id=siko-language-redesign><a href=https://siko-lang.github.io/posts/siko-language-redesign/>Siko language redesign</a></h2><p>For those who encountered Siko before and for some reason still remember it, you may have noticed that the
language has undergone some significant changes.
The goal of this redesign is to improve usability, performance, and overall developer experience.
Both visually and semantically, the language is now an imperative language.</p><pre tabindex=0><code class=language-siko data-lang=siko>module Main {

fn main() {
  println(&#34;Hello, Siko!&#34;);
}

}
</code></pre></div></div></main><table style=margin-top:1em><tr><td><a href=https://github.com/siko-lang/siko target=_blank rel=noopener title=GitHub><img src=/github.svg alt=GitHub height=32 width=32 style=vertical-align:middle;filter:grayscale(1)></a></td><td><a href=https://discord.gg/Gfd8YDrYVC target=_blank rel=noopener title=Discord><img src=/discord.svg alt=Discord height=32 width=32 style=vertical-align:middle></a></td></tr></table><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script src="/siko-syntax.js?v=2025-08-30"></script></body></html>